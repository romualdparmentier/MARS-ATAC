---
title: "Test plot corrélation"
author: "Romuald Parmentier"
date: "26/04/2021"
output: 
  html_document:
    code_folding: hide
    df_print: kable
    highlight: default
    number_sections: yes
    theme: journal  
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: no
      smooth_scroll: yes 
---

<style type="text/css">
  body{
  font-size: 13pt;
}
</style>

```{r setup, include=FALSE, message=FALSE, warning=FALSE}

library(dplyr)
library(propagate)
library(edgebundleR)
library(circlize)
library(stringr)
library(igraph)
library(data.table)

```

```{r BigCOR functions definition, include=FALSE}

### By Gene with BigCor ###
calculate_PearsCor_gene = function(spread_df,timepoint,donor,minCell){
  
  timepoint = timepoint

  donor_num = donor

  spread_df = spread_df %>% filter(donor == donor_num) %>% filter(condition == timepoint) ### Select Time & Donor wanted
  spread_df = spread_df[,5:ncol(spread_df)] ### Remove the 4 first column (not UMI values)
  
  spread_df_sub_bol = spread_df > 0 ### Convert all observation where there is an UMI value and convert it to TRUE or FALSE (if = 0)
  dim(spread_df) == dim(spread_df_sub_bol) ### Check if the dimensions are ok
  
  sum_UMI_parGene = apply(spread_df_sub_bol,2,sum) ### Calculate the sum of TRUE for every column (arg = 2) (Gene) <==> calculate the nb of cell expressing at least one copy of the transcript
  table(sum_UMI_parGene)
  
  shared_genes = which(colSums(spread_df_sub_bol) > minCell) ### Retrieve indices of genes for which the number of cell sharing this genes is > 5
  spread_df = spread_df[,shared_genes] ### Subset only those genes
  
  spread_df = as.matrix(spread_df) ### Transform  df to matrix for bigcor to operate
  spread_df = spread_df +1 ### add +1 for all values (avoid -inf for UMI)
  spread_df = log2(spread_df) ### Transform all UMI values into log2
  
  COR = bigcor(spread_df, fun = "cor", size = 2000) ### Calculate the Pearson Correlation matrix breaking the original matrix into bloc of 2000x2000
  
  COR <- COR[1:nrow(COR), 1:ncol(COR)] ### Reconstitute the matrix with the correct number of row and column
  # all.equal(COR, cor(spread_df)) # => TRUE
  colnames(COR) = colnames(spread_df)
  rownames(COR) = colnames(spread_df)
  
  ## Retrieve all correlation values in a vector in order to calculate mean of correlation values for IC formula
  
  # COR_low = lower.tri(COR) ### Display TRUE for values located only the lower triangle of the matrix
  # COR_low = COR[COR_low] ### Select only the lower triangle matrix (because matrix is symetric)
  # colnames(COR) = colnames(spread_df)
  # rownames(COR) = colnames(spread_df)
  # 
  # dim(COR_low) = NULL ### Transform the matrix into a vector of 1 dimension
  # COR_low = COR_low[!is.na(COR_low)] ### Remove all NA generated by the correlation of full 0 vector with full 0 vector
  # COR_low = abs(COR_low) ### Convert all values in postivie values
  
  # mean_gene = mean(COR_low) ### Calculate the mean value of the vector
  # return(mean_gene)
  
  return(COR)
}

### By Cell with BigCor ###
calculate_PearsCor_cell = function(spread_df,timepoint,donor,minCell){
  
  ### Same commment as calculate_PearsCor_gene function
  
  timepoint = timepoint
  donor_num = donor
  
  spread_df = spread_df %>% filter(donor == donor_num) %>% filter(condition == timepoint)
  spread_df = spread_df[,4:ncol(spread_df)]
  
  spread_df_sub_bol = spread_df > 0 ### Convert all observation where there is an UMI value and convert it to TRUE or FALSE (if = 0)
  dim(spread_df) == dim(spread_df_sub_bol) ### Check if the dimensions are ok
  
  sum_UMI_parGene = apply(spread_df_sub_bol,2,sum) ### Calculate the sum of TRUE for every column (arg = 2) (Gene) <==> calculate the nb of cell expressing at least one copy of the transcript
  table(sum_UMI_parGene)
  
  shared_genes = which(colSums(spread_df_sub_bol) > minCell) ### Retrieve indices of genes for which the number of cell sharing this genes is > 4
  spread_df = spread_df[,shared_genes] ### Subset only those genes
  
  spread_df = as.matrix(spread_df)
  spread_df = t(spread_df) ### Calculate the transposition in order to work on cell correlation and notgeene correlation anymore
  spread_df = spread_df +1
  spread_df = log2(spread_df)
  
  COR = bigcor(spread_df, fun = "cor", size = 2000)
  
  COR <- COR[1:nrow(COR), 1:ncol(COR)]
  # all.equal(COR, cor(spread_df)) # => TRUE
  
  COR_low = lower.tri(COR)
  COR_low = COR[COR_low]
  dim(COR_low) = NULL
  COR_low = COR_low[!is.na(COR_low)]
  mean_cell = mean(COR_low)
  
  return(mean_cell)
  
}

```


# Corrélation facteurs de transcription et gènes cibles
\
But : \
\
Afficher les corrélation entre les gènes codant pour des Facteurs de trnscription (DE et non DE) et leurs cibles.\
==> Pour cette analyse, il n'y a pas de limite sur le nombre de cellules minimum qui doivent partager un gène pour que celui-ci soit pris en compte.\
\
**!! ATTENTION !!** : \
- Comme l'information DE/noDE a été obtenu sur un **interval** de temps, nous avons fusionné la matrice de corrélation des gènes à t et celle des gènes t+24h \
- Les paires de corrélation identiques à t et à t+24h ne sont retenues qu'une seule fois)

## Temps 05h + 24h

### Sélection des TF et de leurs vraies cibles (FANTOM5) (Change et No Change séparés)\

**!! ATTENTION !!**\
Dans cette analyse seules les corrélations entre un TF et leurs "vraies" cibles (FANTOM5) sont prises en compte

```{r Filtration tableau RNAseq_ONLY_TF - 5h-24h - Cibles FANTOM5}

# Load data
spread_df <- read.csv("/home/romuald/Bureau/Analyses_MARS-ATAC/TF_vs_Prom_vs_Expr_redo/input_files/Spread_MARSseq_data_all_filters_20200728.csv", dec=",")
load("/home/romuald/Bureau/Analyses_MARS-ATAC/TF_vs_Prom_vs_Expr_redo/intermediary_generated_files/list_tf_to_prom_and_Gene_expr_Zscore_05_24.rda")
load("/home/romuald/Bureau/Analyses_MARS-ATAC/TF_vs_Prom_vs_Expr_redo/intermediary_generated_files/list_target_genes_Change_NoChange_05_24.rda")

# Rename all columns to get rid of "." because EdgeBundle consider them for grouping data
names = colnames(spread_df)
names = str_split_fixed(names, pattern = "\\.\\.", n=2)
names = names[,1]
names = str_replace_all(names, pattern = "\\.",replacement = "_")
colnames(spread_df) = names

#Extract Condition/Cell/Donor columns

info_spread_df = spread_df[,2:4]
gene_spread_df = spread_df[,5:ncol(spread_df)]

#Liste des TF
list_TF_change = unique(tf_change_list$TF_genes_change$tf)
list_TF_Nochange = unique(tf_change_list$TF_genes_NoChange$tf)
list_TF = c(list_TF_change, list_TF_Nochange)

detected_TF = which(colnames(gene_spread_df) %in% list_TF)
detected_DE_TF = which(colnames(gene_spread_df) %in% list_TF_change)
detected_noDE_TF = which(colnames(gene_spread_df) %in% list_TF_Nochange)

# Paste Prefix to colnames to group data
colnames(gene_spread_df)[detected_DE_TF]= paste("TF_DE", colnames(gene_spread_df)[detected_DE_TF], sep = ".")
colnames(gene_spread_df)[detected_noDE_TF]= paste("TF_noDE", colnames(gene_spread_df)[detected_noDE_TF], sep = ".")

# Listing des target genes (change et No Change) puis filtre du dataset RNAseq
list_target = rbindlist(gene_list)
list_target_name = unique(list_target$Gene)

list_target_Change = list_target %>% filter(Z_score <(-2) | Z_score >2 )
list_target_Change = unique(list_target_Change$Gene)

list_target_NoChange = list_target %>% filter(Z_score <2 & Z_score >-2 )
list_target_NoChange = unique(list_target_NoChange$Gene)

# On utilise le setdiff pour enlever les TF (qui peuvent aussi être des cibles) de la liste des cibles
# Si on ne le fait pas on se retrouve avec des gènes qui sont Target_Change.TF_DE ou Target_NoChang.TF_noDE

detected_target = which(colnames(gene_spread_df) %in% list_target_name)

detected_target_Change = which(colnames(gene_spread_df) %in% list_target_Change)
detected_target_Change = setdiff(detected_target_Change, detected_DE_TF)

detected_target_NoChange = which(colnames(gene_spread_df) %in% list_target_NoChange)
detected_target_NoChange = setdiff(detected_target_NoChange, detected_noDE_TF)

## Paste le prefix selon si target change ou nochange

colnames(gene_spread_df)[detected_target_Change] = paste("Target_Change", 
                                                          colnames(gene_spread_df)[detected_target_Change], 
                                                          sep = ".")

colnames(gene_spread_df)[detected_target_NoChange] = paste("Target_NoChange", 
                                                    colnames(gene_spread_df)[detected_target_NoChange], 
                                                    sep = ".")

# Décommenter si on veut que "Target Gene" représente l'ensemble des gènes qui ne sont pas des TF
# colnames(gene_spread_df)[-detected_TF]= paste("Targets_Gene", colnames(gene_spread_df)[-detected_TF], sep = ".")

# Enlève les gènes reconnu ni en tant que TF, ni en tant que target
gene_spread_df = gene_spread_df[,dplyr::union(detected_TF,detected_target)] 

# Remet les info de cellule, donor etc avec les gènes
spread_df = bind_cols(info_spread_df, gene_spread_df)

```

#### Donor 1
```{r Tidy data and Chord Diagram DONOR 1 - 05h-24h - Cibles FANTOM5, message=FALSE, warning=FALSE}

  # For loop settings
  Time = c("05Hrs","24Hrs")
  COR_cutoff = 0.8
  minCell = 1
  min_link = 1
  donor = 1
  
  list_edges = list()
  list_igraph = list()

  for(i in 1:length(Time)){
    
    ################################################
    ############# Correlation Matrix ###############
    ################################################
    
    COR = calculate_PearsCor_gene(spread_df, timepoint = Time[i], donor = donor, minCell = minCell)
    diag(COR) = 0
    COR[COR<COR_cutoff] = 0
    
    ################################################
    ############### EdgeBundleR ####################
    ################################################
    
    cor_g <- graph_from_adjacency_matrix(COR, mode='undirected', weighted = 'correlation')
    edges <- igraph::as_data_frame(cor_g, 'edges')
    
    multi_from = edges %>%
      group_by(from) %>%
      filter(n()> min_link-1) # min_link -1 parce que si on veut minim 2 liens avec c'est n()>1
    
    multi_to = edges %>%
      group_by(to) %>%
      filter(n()> min_link-1) # min_link -1 parce que si on veut minim 2 liens avec c'est n()>1
    
    edges = bind_rows(multi_from, multi_to) %>% distinct()
    
    
    TF_from = edges %>%
      filter(str_detect(from, pattern = "TF_")) 
    
    TF_to = edges %>%
      filter(str_detect(to, pattern = "TF_")) 
    
    edges = bind_rows(TF_from, TF_to) %>% distinct()
    
    list_edges[[i]]= edges
    list_igraph[[i]] = graph_from_edgelist(as.matrix(edges[,1:2]), directed = F)

  }
  

    #################################################
    ################ Circlize #######################
    #################################################
  
  list_edges_Undirected = list()
  list_comb_edges = list()
  
  for(i in 1:length(list_edges)){
    
    edges_rev = list_edges[[i]][,c(2,1,3)]
    colnames(edges_rev) = c("from","to","correlation")
    comb_edges = bind_rows(list_edges[[i]], edges_rev) %>%
      filter(str_detect(string = from, pattern = "TF_"))
    
    # Pour Circlize il faut transformer associer chaque gène à une catégorie (et donc virer le nom des gènes)
    edges_Undirected = comb_edges %>%
      mutate(from = case_when(str_detect(string = from, pattern = "TF_noDE") ~ "TF_noDE",
        str_detect(string = from, pattern = "TF_DE") ~ "TF_DE")) %>%
      mutate(to = case_when(str_detect(string = to, pattern = "Target_NoChange") ~ "Target_NoChange",
        str_detect(string = to, pattern = "Target_Change") ~ "Target_Change"))  
    
    edges_Undirected = edges_Undirected %>% filter(str_detect(string = to, pattern = "Target")) # Remove TF correlation to TF
  
    list_comb_edges[[i]] = comb_edges 
    list_edges_Undirected[[i]] = edges_Undirected
    
    }

    ##################################################
    ################  Display results ################
    ##################################################
  
    cat(paste("Gènes pris en compte pour le calcul de corrélation : partagés par au moins", minCell, "cellules\n"),
      paste("Seuil de corrélation Pearson : <",COR_cutoff,"\n"),
      paste("Pour qu'un gène soit affiché il doit ciblé ou être la cible d'au moins",min_link,"gènes\n\n")) 
   
    cat(paste("******************************************************************\n"),
      paste("*************** DONNEUR",donor,"TF et cibles exprimés à",Time[1],"*************\n"),
      paste("*******************************************************************\n"))
    
    # cat(paste("Il y a un total de", 
    #           sum(str_count(string = unique(list_comb_edges[[1]]$from), pattern = "TF_DE")),
    #           "TF_DE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[1]]$from)[1]," gènes cibles différents\n"),
    #     paste("Il y a un total de",
    #           sum(str_count(string = unique(list_comb_edges[[1]]$from), pattern = "TF_noDE")), 
    #           "TF_noDE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[1]]$from)[2]," gènes cibles différents"))

    edgebundle(list_igraph[[1]],tension=0.8,fontsize = 10, nodesize = 10)
    
    grid.col = c("TF_DE" = "darkorange1", "TF_noDE" = "deepskyblue4" , "Target_NoChange" = "grey80", "Target_Change" = "green3")
    circos.par(gap.after = c(3,15,3,15))
    chordDiagram(list_edges_Undirected[[1]], grid.col = grid.col)
    
        cat(paste("*************************************************************\n"),
      paste("*************** DONNEUR",donor,"TF et cibles exprimés à",Time[2],"*************\n"),
      paste("********************************************************************\n"))
    
    # cat(paste("Il y a un total de", 
    #           sum(str_count(string = unique(list_comb_edges[[2]]$from), pattern = "TF_DE")),
    #           "TF_DE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[2]]$from)[1]," gènes cibles différents\n"),
    #     paste("Il y a un total de",
    #           sum(str_count(string = unique(list_comb_edges[[2]]$from), pattern = "TF_noDE")), 
    #           "TF_noDE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[2]]$from)[2]," gènes cibles différents"))

    edgebundle(list_igraph[[2]],tension=0.8,fontsize = 10, nodesize = 10)
    
    grid.col = c("TF_DE" = "darkorange1", "TF_noDE" = "deepskyblue4" , "Target_NoChange" = "grey80", "Target_Change" = "green3")
    circos.par(gap.after = c(3,15,3,15))
    chordDiagram(list_edges_Undirected[[2]], grid.col = grid.col)
    
```

#### Donor 2
```{r Tidy data and Chord Diagram DONOR 2 - 05h-24h - Cibles FANTOM5, message=FALSE, warning=FALSE}

  # For loop settings
  Time = c("05Hrs","24Hrs")
  COR_cutoff = 0.8
  minCell = 1
  min_link = 1
  donor = 2
  
  list_edges = list()
  list_igraph = list()

  for(i in 1:length(Time)){
    
    ################################################
    ############# Correlation Matrix ###############
    ################################################
    
    COR = calculate_PearsCor_gene(spread_df, timepoint = Time[i], donor = donor, minCell = minCell)
    diag(COR) = 0
    COR[COR<COR_cutoff] = 0
    
    ################################################
    ############### EdgeBundleR ####################
    ################################################
    
    cor_g <- graph_from_adjacency_matrix(COR, mode='undirected', weighted = 'correlation')
    edges <- igraph::as_data_frame(cor_g, 'edges')
    
    multi_from = edges %>%
      group_by(from) %>%
      filter(n()> min_link-1) # min_link -1 parce que si on veut minim 2 liens avec c'est n()>1
    
    multi_to = edges %>%
      group_by(to) %>%
      filter(n()> min_link-1) # min_link -1 parce que si on veut minim 2 liens avec c'est n()>1
    
    edges = bind_rows(multi_from, multi_to) %>% distinct()
    
    
    TF_from = edges %>%
      filter(str_detect(from, pattern = "TF_")) 
    
    TF_to = edges %>%
      filter(str_detect(to, pattern = "TF_")) 
    
    edges = bind_rows(TF_from, TF_to) %>% distinct()
    
    list_edges[[i]]= edges
    list_igraph[[i]] = graph_from_edgelist(as.matrix(edges[,1:2]), directed = F)

  }
  

    #################################################
    ################ Circlize #######################
    #################################################
  
  list_edges_Undirected = list()
  list_comb_edges = list()
  
  for(i in 1:length(list_edges)){
    
    edges_rev = list_edges[[i]][,c(2,1,3)]
    colnames(edges_rev) = c("from","to","correlation")
    comb_edges = bind_rows(list_edges[[i]], edges_rev) %>%
      filter(str_detect(string = from, pattern = "TF_"))
    
    # Pour Circlize il faut transformer associer chaque gène à une catégorie (et donc virer le nom des gènes)
    edges_Undirected = comb_edges %>%
      mutate(from = case_when(str_detect(string = from, pattern = "TF_noDE") ~ "TF_noDE",
        str_detect(string = from, pattern = "TF_DE") ~ "TF_DE")) %>%
      mutate(to = case_when(str_detect(string = to, pattern = "Target_NoChange") ~ "Target_NoChange",
        str_detect(string = to, pattern = "Target_Change") ~ "Target_Change"))  
    
    edges_Undirected = edges_Undirected %>% filter(str_detect(string = to, pattern = "Target")) # Remove TF correlation to TF
  
    list_comb_edges[[i]] = comb_edges 
    list_edges_Undirected[[i]] = edges_Undirected
    
    }

    ##################################################
    ################  Display results ################
    ##################################################
  
    cat(paste("Gènes pris en compte pour le calcul de corrélation : partagés par au moins", minCell, "cellules\n"),
      paste("Seuil de corrélation Pearson : <",COR_cutoff,"\n"),
      paste("Pour qu'un gène soit affiché il doit ciblé ou être la cible d'au moins",min_link,"gènes\n\n")) 
   
    cat(paste("******************************************************************\n"),
      paste("*************** DONNEUR",donor,"TF et cibles exprimés à",Time[1],"*************\n"),
      paste("*******************************************************************\n"))
    
    # cat(paste("Il y a un total de", 
    #           sum(str_count(string = unique(list_comb_edges[[1]]$from), pattern = "TF_DE")),
    #           "TF_DE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[1]]$from)[1]," gènes cibles différents\n"),
    #     paste("Il y a un total de",
    #           sum(str_count(string = unique(list_comb_edges[[1]]$from), pattern = "TF_noDE")), 
    #           "TF_noDE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[1]]$from)[2]," gènes cibles différents"))

    edgebundle(list_igraph[[1]],tension=0.8,fontsize = 10, nodesize = 10)
    
    grid.col = c("TF_DE" = "darkorange1", "TF_noDE" = "deepskyblue4" , "Target_NoChange" = "grey80", "Target_Change" = "green3")
    circos.par(gap.after = c(3,15,3,15))
    chordDiagram(list_edges_Undirected[[1]], grid.col = grid.col)
    
        cat(paste("*************************************************************\n"),
      paste("*************** DONNEUR",donor,"TF et cibles exprimés à",Time[2],"*************\n"),
      paste("********************************************************************\n"))
    
    # cat(paste("Il y a un total de", 
    #           sum(str_count(string = unique(list_comb_edges[[2]]$from), pattern = "TF_DE")),
    #           "TF_DE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[2]]$from)[1]," gènes cibles différents\n"),
    #     paste("Il y a un total de",
    #           sum(str_count(string = unique(list_comb_edges[[2]]$from), pattern = "TF_noDE")), 
    #           "TF_noDE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[2]]$from)[2]," gènes cibles différents"))

    edgebundle(list_igraph[[2]],tension=0.8,fontsize = 10, nodesize = 10)
    
    grid.col = c("TF_DE" = "darkorange1", "TF_noDE" = "deepskyblue4" , "Target_NoChange" = "grey80", "Target_Change" = "green3")
    circos.par(gap.after = c(3,15,3,15))
    chordDiagram(list_edges_Undirected[[2]], grid.col = grid.col)
    
```


## Temps 24h + 48h

### Sélection des TF et de leurs vraies cibles (FANTOM5) (Change et No Change séparés)\

**!! ATTENTION !!**\
Dans cette analyse seules les corrélations entre un TF et leurs "vraies" cibles (FANTOM5) sont prises en compte

```{r Filtration tableau RNAseq_ONLY_TF - 24h-48h - Cibles FANTOM5}

# Load data
spread_df <- read.csv("/home/romuald/Bureau/Analyses_MARS-ATAC/TF_vs_Prom_vs_Expr_redo/input_files/Spread_MARSseq_data_all_filters_20200728.csv", dec=",")
load("/home/romuald/Bureau/Analyses_MARS-ATAC/TF_vs_Prom_vs_Expr_redo/intermediary_generated_files/list_tf_to_prom_and_Gene_expr_Zscore_24_48.rda")
load("/home/romuald/Bureau/Analyses_MARS-ATAC/TF_vs_Prom_vs_Expr_redo/intermediary_generated_files/list_target_genes_Change_NoChange_24_48.rda")

# Rename all columns to get rid of "." because EdgeBundle consider them for grouping data
names = colnames(spread_df)
names = str_split_fixed(names, pattern = "\\.\\.", n=2)
names = names[,1]
names = str_replace_all(names, pattern = "\\.",replacement = "_")
colnames(spread_df) = names

#Extract Condition/Cell/Donor columns

info_spread_df = spread_df[,2:4]
gene_spread_df = spread_df[,5:ncol(spread_df)]

#Liste des TF
list_TF_change = unique(tf_change_list$TF_genes_change$tf)
list_TF_Nochange = unique(tf_change_list$TF_genes_NoChange$tf)
list_TF = c(list_TF_change, list_TF_Nochange)

detected_TF = which(colnames(gene_spread_df) %in% list_TF)
detected_DE_TF = which(colnames(gene_spread_df) %in% list_TF_change)
detected_noDE_TF = which(colnames(gene_spread_df) %in% list_TF_Nochange)

# Paste Prefix to colnames to group data
colnames(gene_spread_df)[detected_DE_TF]= paste("TF_DE", colnames(gene_spread_df)[detected_DE_TF], sep = ".")
colnames(gene_spread_df)[detected_noDE_TF]= paste("TF_noDE", colnames(gene_spread_df)[detected_noDE_TF], sep = ".")

# Listing des target genes (change et No Change) puis filtre du dataset RNAseq
list_target = rbindlist(gene_list)
list_target_name = unique(list_target$Gene)

list_target_Change = list_target %>% filter(Z_score <(-2) | Z_score >2 )
list_target_Change = unique(list_target_Change$Gene)

list_target_NoChange = list_target %>% filter(Z_score <2 & Z_score >-2 )
list_target_NoChange = unique(list_target_NoChange$Gene)

# On utilise le setdiff pour enlever les TF (qui peuvent aussi être des cibles) de la liste des cibles
# Si on ne le fait pas on se retrouve avec des gènes qui sont Target_Change.TF_DE ou Target_NoChang.TF_noDE

detected_target = which(colnames(gene_spread_df) %in% list_target_name)

detected_target_Change = which(colnames(gene_spread_df) %in% list_target_Change)
detected_target_Change = setdiff(detected_target_Change, detected_DE_TF)

detected_target_NoChange = which(colnames(gene_spread_df) %in% list_target_NoChange)
detected_target_NoChange = setdiff(detected_target_NoChange, detected_noDE_TF)

## Paste le prefix selon si target change ou nochange

colnames(gene_spread_df)[detected_target_Change] = paste("Target_Change", 
                                                          colnames(gene_spread_df)[detected_target_Change], 
                                                          sep = ".")

colnames(gene_spread_df)[detected_target_NoChange] = paste("Target_NoChange", 
                                                    colnames(gene_spread_df)[detected_target_NoChange], 
                                                    sep = ".")

# Décommenter si on veut que "Target Gene" représente l'ensemble des gènes qui ne sont pas des TF
# colnames(gene_spread_df)[-detected_TF]= paste("Targets_Gene", colnames(gene_spread_df)[-detected_TF], sep = ".")

# Enlève les gènes reconnu ni en tant que TF, ni en tant que target
gene_spread_df = gene_spread_df[,dplyr::union(detected_TF,detected_target)] 

# Remet les info de cellule, donor etc avec les gènes
spread_df = bind_cols(info_spread_df, gene_spread_df)

```

#### Donor 1
```{r Tidy data and Chord Diagram DONOR 1 - 24h-48h - Cibles FANTOM5, message=FALSE, warning=FALSE}

  # For loop settings
  Time = c("05Hrs","24Hrs")
  COR_cutoff = 0.8
  minCell = 1
  min_link = 1
  donor = 1
  
  list_edges = list()
  list_igraph = list()

  for(i in 1:length(Time)){
    
    ################################################
    ############# Correlation Matrix ###############
    ################################################
    
    COR = calculate_PearsCor_gene(spread_df, timepoint = Time[i], donor = donor, minCell = minCell)
    diag(COR) = 0
    COR[COR<COR_cutoff] = 0
    
    ################################################
    ############### EdgeBundleR ####################
    ################################################
    
    cor_g <- graph_from_adjacency_matrix(COR, mode='undirected', weighted = 'correlation')
    edges <- igraph::as_data_frame(cor_g, 'edges')
    
    multi_from = edges %>%
      group_by(from) %>%
      filter(n()> min_link-1) # min_link -1 parce que si on veut minim 2 liens avec c'est n()>1
    
    multi_to = edges %>%
      group_by(to) %>%
      filter(n()> min_link-1) # min_link -1 parce que si on veut minim 2 liens avec c'est n()>1
    
    edges = bind_rows(multi_from, multi_to) %>% distinct()
    
    
    TF_from = edges %>%
      filter(str_detect(from, pattern = "TF_")) 
    
    TF_to = edges %>%
      filter(str_detect(to, pattern = "TF_")) 
    
    edges = bind_rows(TF_from, TF_to) %>% distinct()
    
    list_edges[[i]]= edges
    list_igraph[[i]] = graph_from_edgelist(as.matrix(edges[,1:2]), directed = F)

  }
  

    #################################################
    ################ Circlize #######################
    #################################################
  
  list_edges_Undirected = list()
  list_comb_edges = list()
  
  for(i in 1:length(list_edges)){
    
    edges_rev = list_edges[[i]][,c(2,1,3)]
    colnames(edges_rev) = c("from","to","correlation")
    comb_edges = bind_rows(list_edges[[i]], edges_rev) %>%
      filter(str_detect(string = from, pattern = "TF_"))
    
    # Pour Circlize il faut transformer associer chaque gène à une catégorie (et donc virer le nom des gènes)
    edges_Undirected = comb_edges %>%
      mutate(from = case_when(str_detect(string = from, pattern = "TF_noDE") ~ "TF_noDE",
        str_detect(string = from, pattern = "TF_DE") ~ "TF_DE")) %>%
      mutate(to = case_when(str_detect(string = to, pattern = "Target_NoChange") ~ "Target_NoChange",
        str_detect(string = to, pattern = "Target_Change") ~ "Target_Change"))  
    
    edges_Undirected = edges_Undirected %>% filter(str_detect(string = to, pattern = "Target")) # Remove TF correlation to TF
  
    list_comb_edges[[i]] = comb_edges 
    list_edges_Undirected[[i]] = edges_Undirected
    
    }

    ##################################################
    ################  Display results ################
    ##################################################
  
    cat(paste("Gènes pris en compte pour le calcul de corrélation : partagés par au moins", minCell, "cellules\n"),
      paste("Seuil de corrélation Pearson : <",COR_cutoff,"\n"),
      paste("Pour qu'un gène soit affiché il doit ciblé ou être la cible d'au moins",min_link,"gènes\n\n")) 
   
    cat(paste("******************************************************************\n"),
      paste("*************** DONNEUR",donor,"TF et cibles exprimés à",Time[1],"*************\n"),
      paste("*******************************************************************\n"))
    
    # cat(paste("Il y a un total de", 
    #           sum(str_count(string = unique(list_comb_edges[[1]]$from), pattern = "TF_DE")),
    #           "TF_DE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[1]]$to)[1],"gènes cibles différents (DE)\n"),
    #           "ET avec un total de",
    #           table(list_edges_Undirected[[1]]$to)[2],"gènes cibles différents (noDE)")
    #           
    # cat(paste("Il y a un total de", 
    #           sum(str_count(string = unique(list_comb_edges[[1]]$from), pattern = "TF_noDE")),
    #           "TF_noDE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[1]]$to)[1],"gènes cibles différents (DE)\n"),
    #           "ET avec un total de",
    #           table(list_edges_Undirected[[1]]$to)[2],"gènes cibles différents (noDE)")

    edgebundle(list_igraph[[1]],tension=0.8,fontsize = 10, nodesize = 10)
    
    grid.col = c("TF_DE" = "darkorange1", "TF_noDE" = "deepskyblue4" , "Target_NoChange" = "grey80", "Target_Change" = "green3")
    circos.par(gap.after = c(3,15,3,15))
    chordDiagram(list_edges_Undirected[[1]], grid.col = grid.col)
    
        cat(paste("*************************************************************\n"),
      paste("*************** DONNEUR",donor,"TF et cibles exprimés à",Time[2],"*************\n"),
      paste("********************************************************************\n"))
    
    # cat(paste("Il y a un total de", 
    #           sum(str_count(string = unique(list_comb_edges[[2]]$from), pattern = "TF_DE")),
    #           "TF_DE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[2]]$from)[1]," gènes cibles différents\n"),
    #     paste("Il y a un total de",
    #           sum(str_count(string = unique(list_comb_edges[[2]]$from), pattern = "TF_noDE")), 
    #           "TF_noDE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[2]]$from)[2]," gènes cibles différents"))

    edgebundle(list_igraph[[2]],tension=0.8,fontsize = 10, nodesize = 10)
    
    grid.col = c("TF_DE" = "darkorange1", "TF_noDE" = "deepskyblue4" , "Target_NoChange" = "grey80", "Target_Change" = "green3")
    circos.par(gap.after = c(3,15,3,15))
    chordDiagram(list_edges_Undirected[[2]], grid.col = grid.col)
    
```

#### Donor 2
```{r Tidy data and Chord Diagram DONOR 2 - 24h-48h - Cibles FANTOM5, message=FALSE, warning=FALSE}

  # For loop settings
  Time = c("05Hrs","24Hrs")
  COR_cutoff = 0.8
  minCell = 1
  min_link = 1
  donor = 2
  
  list_edges = list()
  list_igraph = list()

  for(i in 1:length(Time)){
    
    ################################################
    ############# Correlation Matrix ###############
    ################################################
    
    COR = calculate_PearsCor_gene(spread_df, timepoint = Time[i], donor = donor, minCell = minCell)
    diag(COR) = 0
    COR[COR<COR_cutoff] = 0
    
    ################################################
    ############### EdgeBundleR ####################
    ################################################
    
    cor_g <- graph_from_adjacency_matrix(COR, mode='undirected', weighted = 'correlation')
    edges <- igraph::as_data_frame(cor_g, 'edges')
    
    multi_from = edges %>%
      group_by(from) %>%
      filter(n()> min_link-1) # min_link -1 parce que si on veut minim 2 liens avec c'est n()>1
    
    multi_to = edges %>%
      group_by(to) %>%
      filter(n()> min_link-1) # min_link -1 parce que si on veut minim 2 liens avec c'est n()>1
    
    edges = bind_rows(multi_from, multi_to) %>% distinct()
    
    
    TF_from = edges %>%
      filter(str_detect(from, pattern = "TF_")) 
    
    TF_to = edges %>%
      filter(str_detect(to, pattern = "TF_")) 
    
    edges = bind_rows(TF_from, TF_to) %>% distinct()
    
    list_edges[[i]]= edges
    list_igraph[[i]] = graph_from_edgelist(as.matrix(edges[,1:2]), directed = F)

  }
  

    #################################################
    ################ Circlize #######################
    #################################################
  
  list_edges_Undirected = list()
  list_comb_edges = list()
  
  for(i in 1:length(list_edges)){
    
    edges_rev = list_edges[[i]][,c(2,1,3)]
    colnames(edges_rev) = c("from","to","correlation")
    comb_edges = bind_rows(list_edges[[i]], edges_rev) %>%
      filter(str_detect(string = from, pattern = "TF_"))
    
    # Pour Circlize il faut transformer associer chaque gène à une catégorie (et donc virer le nom des gènes)
    edges_Undirected = comb_edges %>%
      mutate(from = case_when(str_detect(string = from, pattern = "TF_noDE") ~ "TF_noDE",
        str_detect(string = from, pattern = "TF_DE") ~ "TF_DE")) %>%
      mutate(to = case_when(str_detect(string = to, pattern = "Target_NoChange") ~ "Target_NoChange",
        str_detect(string = to, pattern = "Target_Change") ~ "Target_Change"))  
    
    edges_Undirected = edges_Undirected %>% filter(str_detect(string = to, pattern = "Target")) # Remove TF correlation to TF
  
    list_comb_edges[[i]] = comb_edges 
    list_edges_Undirected[[i]] = edges_Undirected
    
    }

    ##################################################
    ################  Display results ################
    ##################################################
  
    cat(paste("Gènes pris en compte pour le calcul de corrélation : partagés par au moins", minCell, "cellules\n"),
      paste("Seuil de corrélation Pearson : <",COR_cutoff,"\n"),
      paste("Pour qu'un gène soit affiché il doit ciblé ou être la cible d'au moins",min_link,"gènes\n\n")) 
   
    cat(paste("******************************************************************\n"),
      paste("*************** DONNEUR",donor,"TF et cibles exprimés à",Time[1],"*************\n"),
      paste("*******************************************************************\n"))
    # 
    # cat(paste("Il y a un total de", 
    #           sum(str_count(string = unique(list_comb_edges[[1]]$from), pattern = "TF_DE")),
    #           "TF_DE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[1]]$from)[1]," gènes cibles différents\n"),
    #     paste("Il y a un total de",
    #           sum(str_count(string = unique(list_comb_edges[[1]]$from), pattern = "TF_noDE")), 
    #           "TF_noDE qui corrèlent avec un total de",
    #           table(list_edges_Undirected[[1]]$from)[2]," gènes cibles différents"))

    edgebundle(list_igraph[[1]],tension=0.8,fontsize = 10, nodesize = 10)
    
    grid.col = c("TF_DE" = "darkorange1", "TF_noDE" = "deepskyblue4" , "Target_NoChange" = "grey80", "Target_Change" = "green3")
    circos.par(gap.after = c(3,15,3,15))
    chordDiagram(list_edges_Undirected[[1]], grid.col = grid.col)
    
        cat(paste("*************************************************************\n"),
      paste("*************** DONNEUR",donor,"TF et cibles exprimés à",Time[2],"*************\n"),
      paste("********************************************************************\n"))
    
      # cat(paste("Il y a un total de", 
      #           sum(str_count(string = unique(list_comb_edges[[2]]$from), pattern = "TF_DE")),
      #           "TF_DE qui corrèlent avec un total de",
      #           table(list_edges_Undirected[[2]]$from)[1]," gènes cibles différents\n"),
      #     paste("Il y a un total de",
      #           sum(str_count(string = unique(list_comb_edges[[2]]$from), pattern = "TF_noDE")), 
      #           "TF_noDE qui corrèlent avec un total de",
      #           table(list_edges_Undirected[[2]]$from)[2]," gènes cibles différents"))

    edgebundle(list_igraph[[2]],tension=0.8,fontsize = 10, nodesize = 10)
    
    grid.col = c("TF_DE" = "darkorange1", "TF_noDE" = "deepskyblue4" , "Target_NoChange" = "grey80", "Target_Change" = "green3")
    circos.par(gap.after = c(3,15,3,15))
    chordDiagram(list_edges_Undirected[[2]], grid.col = grid.col)
    
```


