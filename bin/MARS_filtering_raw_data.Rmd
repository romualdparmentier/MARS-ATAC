---
title: "Data brutes : filtres"
author: "Romuald & Laëitia"
date: "6 mars 2020"
output:
  html_document:
    code_folding: "hide"
editor_options: 
  chunk_output_type: inline
---

Le but de ce document est d'expliciter toutes les étapes de filtre par lesquelles nos data brutes passent avant d'être utilisées pour  Calista ou autres 

```{r setup, include=FALSE}

setwd(dir = "/home/romuald/Bureau/MARS_seq_temp/Data_analyse/Filtering_data_brut")

suppressMessages(library(data.table))
suppressMessages(library(rlang))
suppressMessages(library(dplyr))
suppressMessages(library(readr))
suppressMessages(library(tidyr))
suppressMessages(library(ggplot2))
suppressMessages(library(stringr))
suppressMessages(library(reshape))
suppressMessages(library(Rtsne))
suppressMessages(library(knitr))
```

```{r function, include=FALSE}

# Fonction qui permet de retourner le nombre de cellules éliminées par le filtre
count_cell_filtered_function = function(df){
  
  count_cell = as.data.frame(table(df$cell,
                           df$condition,
                           df$donor))

cell_filtered = count_cell %>% filter(Freq == 0)

count_filtered = as.data.frame(table(cell_filtered$Freq,
                                     cell_filtered$Var2,
                                     cell_filtered$Var3)
                               )

colnames(count_filtered) = c("Filter","Time","Donor","Nb_cell_filtered") 

return(count_filtered[,4])

}

# Fonction qui permet de muliplier les lignes en fonction d'une colonne qui contient en fait plusieurs lignes 
# Fait le même travail que unnest de dplyr, mais en BCP plus efficace (100x plus rapide)
unnest_dt <- function(tbl, col) {
  
  tbl <- as.data.table(tbl)
  
  col <- ensyms(col)
  
  clnms <- syms(setdiff(colnames(tbl), as.character(col)))
  
  tbl <- as.data.table(tbl)
  
  tbl <- eval(
    expr(tbl[, as.character(unlist(!!!col)), by = list(!!!clnms)])
  )
  
  colnames(tbl) <- c(as.character(clnms), as.character(col))
  
  tbl
}

```


# Loading des data brutes

- Le fichiers H619_annotation_AM.bed est le fichier brute de sortie d'alignement  

```{r Loading des data brutes, warning = FALSE}
data <- as.data.frame(fread("/home/romuald/Bureau/MARS_seq_temp/Data_analyse/Filtering_data_brut/H619_annotation_AM.bed"))
# Fread est une fonction de data.table qui permet d'ouvrir plus rapidement ce genre de tableau volumineux

kable(data[1:5,])# Ces colonnes regroupet toutes les info expérimentales

```

- Le fichier Normalization_R0.6_pool_duplicate est le fichier qui résume les scores de Pearson pour toutes les cellules  
  ==> Les cellules avec un score < 0.6 seront écartées par la suite  
  ==> Les valeurs a et b sont les coefficients de la droite de regression obtenue grâce aux ERCC  
   
```{r Loading des data brutes bis}

Normalization_R0.6 = read.table(file = "/home/romuald/Bureau/MARS_seq_temp/Data_analyse/Filtering_data_brut/Normalization_R0.6_pool_duplicate.txt")

kable(Normalization_R0.6[1:5,])

```

# Réorganisation du tableau et premiers filtres

- On enlève le chr y et les genes qui ne mappent nul part
- On rajoute le nom du transcript dans une nouvelle colonne appelée transcript_name 
- Comme un gène se retrouve parfois dans 2 chr différents ou + : nouvelle colonne "Transcript_name_chr" le nom du gene + le chr

```{r Réorga tableau et 1er filtre}

df = filter(data, !chr %in% c("chrY")) %>% 
     mutate(chr=factor(chr,levels=c(paste0("chr",1:22),"chrX","chrM"))) %>% 
     arrange(cell,chr) %>%
     mutate(gene_type = str_match(string = gene,pattern="gene_type ([A-Za-z0-9._-]+)")[,2],
                             transcript_id = str_match(string = gene,pattern="transcript_id (ENSG[0-9]+)")[,2],
                             transcript_name = str_match(string = gene,pattern="transcript_name ([A-Za-z0-9._-]+)")[,2],
                             transcript_status = str_match(string = gene,pattern="transcript_status ([A-Z]+)")[,2],
                             transcript_name_chr = str_c(transcript_name,chr, sep="; "))

kable(df[1:5,1:7])
kable(df[1:5,8:14])

```

# Filtres sur les cellules et sur les gènes  
  
- A noter que les filtres sont cumulatifs dans l'odre où ils sont présentés  

## Filtre sur les cellules  

- Au total, nous avons préparé des librairies pour 5 conditions de temps, 2 donneurs et 96 cellules/condition :      

```{r Création tableau recap filtres sur cellules}

recap_cell_filter = data.frame("Time" = rep(c("00Hrs","24Hrs","48Hrs","72Hrs","96Hrs"),2),
                             "Donor" = c(rep(1,5),rep(2,5)),
                             "nb_cell_brut" = rep(96,10))

kable(recap_cell_filter)

```

### Filtre sur le nombre de read total/cellule  

- Les cellules avec un total de reads détecté inférieur à 80K sont filtrées

```{r plot }

df_read_plot = df %>% group_by(condition, cell, donor) %>% 
  summarise(reads_tot = sum(reads_sum)) %>%
  ungroup() %>%
  group_by(condition, cell, donor) %>%
  summarise(reads_tot = unique(reads_tot))

plot = ggplot(data = df_read_plot, aes(df_read_plot$reads_tot)) +
  geom_histogram(bins = 100, fill = "white", colour = "black") +
  geom_vline(xintercept = 80000, color = "red", linetype = "dashed" ) +
  xlab(label = "nb reads total (d1 & d2 merged)") +
  geom_text(x = 1250000, y = 40, label = "< 80 000 reads = 134") + 
  geom_text(x = 1250000, y = 35, label = "> 80 000 reads = 826")  

plot

```

```{r Filtre reads totaux/cellule}

df_cell_filter = df %>% group_by(condition, cell, donor) %>% 
  summarise(reads_tot = sum(reads_sum)) %>% #On somme les reads obtenus pour chacun des gènes dans chacune des cellule/temps/donneur
  filter(reads_tot > 80000) %>% #Les cellules avec moins de 80K reads sont filtrées
  ungroup() %>%
  inner_join(df,by = c("condition","cell","donor"))

# On affiche le nombre de cellules affectées par ce filtre :

recap_cell_filter = recap_cell_filter %>%
  mutate(nb_cell_UMI_sum_filter = recap_cell_filter[,"nb_cell_brut"]-count_cell_filtered_function(df_cell_filter))

kable(recap_cell_filter)

```

### Filtre sur la proportion de chromosome M  

- Les cellules dont la proportion de gènes mitochondriaux est supérieure à 10% sont filtrées (car : ref)

```{r Filtre proportion chrM}

# On calcule d'abord le % de chaque chr pour chaque cellule
df_temp = df_cell_filter %>% group_by(condition,cell,donor,chr) %>%
  summarise(UMI_number = sum(UMI_sum)) %>% 
  ungroup() %>%
  group_by(condition,cell,donor) %>% 
  mutate(percentage_chr_per_cell = UMI_number/sum(UMI_number))

df_temp = df_temp %>% ungroup() %>% 
  filter(chr == "chrM") %>% # On ne garde que l'info du chromosome M
  filter(percentage_chr_per_cell <= 0.1) # On créé une liste avec seules les cellules < 10% pour le chrM

# Application du filtre sur les données
df_cell_filter = inner_join(df_cell_filter,df_temp[,1:3], by = c("condition","cell","donor")) %>%
  filter(!chr %in% "chrM")

# On affiche le nombre de cellules affectées par ce filtre :

recap_cell_filter = recap_cell_filter %>%
  mutate(nb_cell_chrM_prop_filter = recap_cell_filter[,"nb_cell_brut"]-count_cell_filtered_function(df_cell_filter))

kable(recap_cell_filter)

```

### Filtre sur linéarité d'amplification  

- Les cellules qui ne présentent pas une bonne corrélation (>= 0.6) entre la quantité attendue de spike et la quantité réellement détectée après séquençage sont oconsidérées comme des cellules n'ayant pas subit une amplification linéaire satisfaisante  

```{r Filtre linéarité amplification, warning = FALSE}

  df_cell_filter = suppressMessages(df_cell_filter %>% inner_join(Normalization_R0.6[,c(1,2,3)], 
                       by = c("condition","cell","donor")))
# Le tableau de normalisation contient déjà que les cellules avec un coeff > 0.6

# On affiche le nombre de cellules affectées par ce filtre :

recap_cell_filter = recap_cell_filter %>%
  mutate(nb_cell_Pearson_filter = recap_cell_filter[,"nb_cell_brut"]-count_cell_filtered_function(df_cell_filter))

kable(recap_cell_filter)

```


## Filtre sur les gènes  
  
- Pour pouvoir visualiser l'effet de ces filtres sur les gènes, le tableau qui récapitule les filtes sera composé de la quinzième (pourquoi ? Parce que.) cellule de chaque condition pour chaque donneur.

```{r Création tableau recap filtre gènes}

  recap_gene_filter = as.data.frame(table(df_cell_filter$cell, 
                                             df_cell_filter$condition, 
                                             df_cell_filter$donor)) %>% filter(Var1 == "TAG15")

  colnames(recap_gene_filter) = c("Cell","Time","Donor","nb_gene_brut")
  
  kable(recap_gene_filter)

```


### Filtre sur la nature des transcrits  
   
  - On ne gare que les transcrits qui ont la mention "protein coding" et parmis ceux-là on filtre ceux qui portent la mention "putative"  
    
```{r Filtre nature des transcrits}
 
  df_gene_filter = df_cell_filter %>% filter(gene_type == "protein_coding", !transcript_status == "PUTATIVE") 

  new_col = as.data.frame(table(df_gene_filter$cell, 
                                df_gene_filter$condition, 
                                df_gene_filter$donor)) %>% filter(Var1 == "TAG15")
  
  colnames(new_col) = c("Cell","Time","Donor","nb_gene_type_filter")
  recap_gene_filter = recap_gene_filter %>% inner_join(new_col, by = c("Cell","Time","Donor"))

  kable(recap_gene_filter)
  
```


```{r Séparation du tableau, results = 'hide'}

# Si un gène à 3 UMI, on va créer 3 lignes (une ligne par UMI, tout en gardant toutes les autres informations)
# Etape longue, car jusqu' à 256 UMI par gène (4^4)

# Menage dans les tableaux
rm(df, data, df_cell_filter, df_temp, new_col)
suppressMessages(gc())

# Menage dans le tableau
df_gene_filter = df_gene_filter[,-c(6,7,9,11,13,14)]

# On transforme la colonne UMIs (ex : "CAAA, GGGG") en liste (ex : "CAAA" "GGGG")
df_gene_filter = df_gene_filter %>%
  mutate(UMI = str_split(UMIs, pattern = ","))  

# On ajoute une ligne par UMI détecté dans les listes crées précédement 
df_part_2 = unnest_dt(df_gene_filter,UMI)[] # Fonction récupérée sur internet qui fait fonctionner data.table (100x plus rapide)
UMI_temp = as.data.frame(df_part_2[,10]) # On stock cet élément

# On transforme la colonne readss (ex : "111, 2") en liste (ex : "111" "2")
df_gene_filter = df_gene_filter %>% mutate(reads = str_split(readss, pattern = ",")) %>% select(-UMI)
df_gene_filter = unnest_dt(df_gene_filter,reads)

# On fait fusionner les deux tableaux unnest
df_gene_filter = df_gene_filter %>% bind_cols(UMI_temp)
df_gene_filter = df_gene_filter[,c(-6,-7)]

rm(df_part_2)
rm(UMI_temp)

```

### Filtre redondance UMI vs ENSG   
  
- Parfois, on a le nom du transcript+chr qui a 2 ID_ENSG différents et qui pourtant ont exactment LES mêmes UMI   
 Explication: 
 ==> Le même read mappe dans 2 gènes "differents" (orthologues)  
 ==> ou le même gène a deux status différents (novel/known)  
 ==> Je garde uniquement l'un des 2 ENSG.  

- Certains gènes ont tous les paramètres identiques, mais un nombre de reads différens, il s'agit de vrais dupliquats techniques pour lequels il convient de sommer les reads obtenus   
  
```{r Filtre duplicats UMI}

# Vérifier s'il y a des lignes dupliquées  (totalement identiques) (si oui, les sommer, sinon elles partiront dans le filtre suivant)
dup_row = duplicated(df_gene_filter) | duplicated(df_gene_filter, fromLast = TRUE)
table(dup_row) # Il n'y en a pas, donc pas de somme 

# Duplicats virtuels (mauvais)
# Si tout pareil, mais ENSG différents
# ==> Alors on ne garde qu'une seule des deux ENSG (car c'est le même read!)

# df_gene_filter_f1 = df_gene_filter %>% 
#   group_by(condition, cell, donor, chr, reads_tot, transcript_name_chr, UMI, reads) %>% 
#   distinct(transcript_name_chr, .keep_all = T) %>% #ne garde qu'une des deux lignes
#   ungroup()

load("/home/romuald/Bureau/MARS_seq_temp/Data_analyse/Filtering_data_brut/df_gene_filter1") # Tableau généré sur un rdi avec plus de RAM (env 20Gb nécessaires)

# Vrai duplicats tech sommés

# df_gene_filter_f2 = df_gene_filter_f1 %>% 
#   group_by(condition, cell, donor, reads_tot, chr, transcript_id, transcript_name_chr, UMI) %>% 
#   summarise(reads = sum(as.numeric(reads))) %>% # Somme des vrais dupliquats techniques (tout pareil sauf nb reads)
#   ungroup()

load("/home/romuald/Bureau/MARS_seq_temp/Data_analyse/Filtering_data_brut/df_gene_filter2") # Tableau généré sur un rdi avec plus de RAM (env 20Gb nécessaires)

  df_duplicate_filter = data.frame("Nb_tot_bulk_brut" = nrow(df_gene_filter),
                                   "remove_virtual_Duplicate" = nrow(df_gene_filter_f1),
                                   "merge_real_duplicate" = nrow(df_gene_filter_f2))
  
  rownames(df_duplicate_filter) = "nb_total_gene_bulk"

  kable(df_duplicate_filter)

```

```{r Menage, include = FALSE}
  df_gene_filter = df_gene_filter_f2
  rm(df_gene_filter_f1, df_gene_filter_f2)
  gc()
```

### Filtre sur le nombre de reads détecté par gènes  
  
- Si un gène n'a été détecté qu'avec un total de un seul reads, il est considéré comme étant une erreur expériemntale  
  
```{r Filtre  reads/gène}

df_gene_filter = df_gene_filter %>% filter(reads > 1)

### Visualisation de l'effet du filtre sur le nombre total de gènes :

df_duplicate_filter["reads_inferior_1"] = nrow(df_gene_filter)
kable(df_duplicate_filter)

# On regroupe les gènes par leur nom et on somme les reads et les UMI :
df_gene_filter = df_gene_filter %>%
group_by(condition, cell, donor, transcript_name_chr) %>% # Regroupe UMI identiques réplicats tech sur flowcell
  summarise(read_sum = sum(reads),
            UMI_sum = n_distinct(UMI)) 

### Visualisation de l'effet du filtre reads < 1 sur une seule cellule :
  
    new_col = as.data.frame(table(df_gene_filter$cell, 
                                df_gene_filter$condition, 
                                df_gene_filter$donor)) %>% filter(Var1 == "TAG15")
  
  colnames(new_col) = c("Cell","Time","Donor","reads_inferior_1")
  recap_gene_filter = recap_gene_filter %>% inner_join(new_col, by = c("Cell","Time","Donor"))
  
  kable(recap_gene_filter)
  
```


### Filtre sur la somme des UMI par gène  
  
- Si un gène n'a été détecté qu'avec un total de un seul UMI, il est considéré comme étant une erreur expériemntale  
  
```{r Filtre somme UMI/gène}

### Filtre UMI < 1
  
  df_gene_filter = df_gene_filter %>% filter(UMI_sum > 1)
  
  ### Visualisation de l'effet du filtre UMIs < 1 :
  
    new_col = as.data.frame(table(df_gene_filter$cell, 
                                df_gene_filter$condition, 
                                df_gene_filter$donor)) %>% filter(Var1 == "TAG15")
  
  colnames(new_col) = c("Cell","Time","Donor","UMIs_inferior_1")
  recap_gene_filter = recap_gene_filter %>% inner_join(new_col, by = c("Cell","Time","Donor"))
  
   kable(recap_gene_filter)

```
  
### Extrapolation nb molecules  
  
- Grâce aux spikes présent dans chaque cellule et à la droite de régression linéaire qu'il a été possible de tracer grâce à eux, on peut estimer le nombre de molecule  propre à chaque cellule pour chaque gène  
  
```{r Molecules and export, warning = FALSE}

df_gene_filter = df_gene_filter %>% 
  inner_join(Normalization_R0.6[,c(1,2,3,6,7)], by = c("condition","cell","donor")) %>%
  mutate(molecules = exp((log(UMI_sum)-b)/a))

save(df_gene_filter,file = "MARSseq_data_all_filters_20200306.rda") # Gene = lignes, cellules = colonnes
write.csv2(df_gene_filter, file = "MARSseq_data_all_filters_20200306.csv")

df_gene_filter = df_gene_filter[,-c(5,7,8,9)]
spread_df = spread(df_gene_filter,transcript_name_chr,UMI_sum)
spread_df = spread_df %>% replace(is.na(.),0)
save(spread_df, file = "Spread_MARSseq_data_all_filters_20200306.rda") # Cellules = lignes, gènes = colonnes
write.csv2(spread_df, file = "Spread_MARSseq_data_all_filters_20200306_2.csv")

spread_df_d1 = spread_df %>% filter(donor == 1)
save(spread_df_d1, file = "Spread_MARSseq_data_all_filters_20200306_d1.rda") # Cellules = lignes, gènes = colonnes
write.csv2(spread_df_d1, file = "Spread_MARSseq_data_all_filters_20200306_d1.csv")

spread_df_d2 = spread_df %>% filter(donor == 2)
save(spread_df_d2, file = "Spread_MARSseq_data_all_filters_20200306_d2.rda") # Cellules = lignes, gènes = colonnes
write.csv2(spread_df_d2, file = "Spread_MARSseq_data_all_filters_20200306_d2.csv")

```


## Exploration données  
  
```{r Nb moyen de gène/cellule}

df_gene_filter_avg = df_gene_filter %>%
  group_by(condition, cell, donor) %>%
  summarise(nb_genes = length(unique(transcript_name_chr))) %>%
  ungroup() 

avg_plot  = ggplot(df_gene_filter_avg,aes(x=condition,y=nb_genes))+
  geom_boxplot() +
  xlab("")+
  ylab("Mean of genes per cell") +
  facet_wrap(~donor)

avg_plot

df_gene_filter_avg = df_gene_filter_avg %>%
  group_by(condition,donor) %>%
  summarise(avg_genes/cell = round(mean(nb_genes),0),
            sd_genes = round(sd(nb_genes),0))

kable(df_gene_filter_avg)
```

test = UMI_data %>% group_by(donor,condition) %>% summarise(nb_genes = n_distinct(tra))
